1)translate trkcsp_get_load_locview  go
;*** Generated by TRANSLATE, verify before re-including (Debug:N,Optimize:Y,DiffEnd:N,Rdb:N) ***
DROP PROGRAM trkcsp_get_load_locview:dba GO
CREATE PROGRAM trkcsp_get_load_locview:dba
 RECORD reply(
   1 qual[*]
     2 code = f8
     2 desc = vc
     2 cdf = vc
     2 status = vc
     2 status_cd = f8
     2 pt_count = i2
     2 held_for = vc
     2 held_count = i2
   1 status_data
     2 status = c1
     2 subeventstatus[1]
       3 operationname = c25
       3 operationstatus = c1
       3 targetobjectname = c25
       3 targetobjectvalue = vc
 )
 FREE RECORD rcheckout
 RECORD rcheckout(
   1 list[*]
     2 cd = f8
 )
 RECORD lg(
   1 lg[*]
     2 parent_loc_cd = f8
     2 child_loc_cd = f8
     2 sequence = i4
     2 sequence_lg2 = i4
     2 lg1[*]
       3 child_loc_cd = f8
       3 sequence = i4
       3 status_cd = f8
 )
 RECORD temp(
   1 qual[*]
     2 code = f8
     2 desc = vc
     2 cdf = vc
     2 status = vc
     2 status_cd = f8
     2 sequence_lg1 = i4
     2 sequence = i4
     2 sequence_lg2 = i4
 )
 FREE RECORD pref_request
 RECORD pref_request(
   1 context = vc
   1 context_id = vc
   1 section = vc
   1 section_id = vc
   1 groups[*]
     2 name = vc
   1 debug = vc
 )
 FREE RECORD pref_reply
 RECORD pref_reply(
   1 entries[*]
     2 name = vc
     2 values[*]
       3 value = vc
   1 status_data
     2 status = c1
     2 subeventstatus[1]
       3 operationname = c25
       3 operationstatus = c1
       3 targetobjectname = c25
       3 targetobjectvalue = vc
 )
 SUBROUTINE (getexpandind(_reccnt=i4(value),_bindcnt=i4(value,200)) =i2)
   DECLARE nexpandval = i4 WITH private, noconstant(1)
   DECLARE ncurrentverion = i4 WITH private, constant(cnvtint(build(currev,currevminor,currevminor2))
    )
   IF (ncurrentverion >= 8102)
    SET nexpandval = 2
   ENDIF
   RETURN(evaluate(floor(((_reccnt - 1)/ _bindcnt)),0,0,nexpandval))
 END ;Subroutine
 DECLARE fncomplete = f8 WITH private, noconstant(curtime3)
 SET reply->status_data.status = "S"
 DECLARE dambulatorycd = f8 WITH constant(uar_get_code_by("MEANING",222,"AMBULATORY"))
 DECLARE dnurseunitcd = f8 WITH constant(uar_get_code_by("MEANING",222,"NURSEUNIT"))
 DECLARE dradcd = f8 WITH constant(uar_get_code_by("MEANING",222,"RAD"))
 DECLARE dlabcd = f8 WITH constant(uar_get_code_by("MEANING",222,"LAB"))
 DECLARE dsurgcd = f8 WITH constant(uar_get_code_by("MEANING",222,"ANCILSURG"))
 DECLARE dfollowupambcd = f8 WITH constant(uar_get_code_by("MEANING",222,"FOLLOWUPAMB"))
 DECLARE lgcount = i4 WITH noconstant(0)
 DECLARE lg1count = i4 WITH noconstant(0)
 DECLARE totalcount = i4 WITH noconstant(0)
 DECLARE replycount = i4 WITH noconstant(0)
 DECLARE parentdisplay = vc
 DECLARE childdisplay = vc
 DECLARE lvindex = i4 WITH noconstant(0)
 DECLARE idx = i4 WITH noconstant(0)
 DECLARE idx2 = i4 WITH noconstant(0)
 DECLARE stat = i4 WITH noconstant(0)
 DECLARE fnretrievelocationview = f8 WITH private, noconstant(curtime3)
 SELECT INTO "nl:"
  FROM location_group lg
  WHERE lg.location_group_type_cd IN (dambulatorycd, dnurseunitcd, dradcd, dlabcd, dsurgcd,
  dfollowupambcd)
   AND (lg.root_loc_cd=request->view_id)
   AND lg.active_ind=1
   AND lg.beg_effective_dt_tm <= cnvtdatetime(sysdate)
   AND lg.end_effective_dt_tm >= cnvtdatetime(sysdate)
  DETAIL
   lgcount += 1, stat = alterlist(lg->lg,lgcount), lg->lg[lgcount].parent_loc_cd = lg.parent_loc_cd,
   lg->lg[lgcount].child_loc_cd = lg.child_loc_cd, lg->lg[lgcount].sequence = lg.sequence
  WITH nocounter
 ;end select
 CALL echo(build("FNRetrieveLocationView -> ",build2(cnvtint((curtime3 - fnretrievelocationview))),
   "0 ms"))
 DECLARE fnretrievenurseunit = f8 WITH private, noconstant(curtime3)
 SELECT INTO "nl:"
  FROM location_group lg2
  WHERE expand(idx,1,lgcount,lg2.child_loc_cd,lg->lg[idx].parent_loc_cd)
   AND (lg2.root_loc_cd=request->view_id)
   AND lg2.active_ind=1
   AND lg2.beg_effective_dt_tm <= cnvtdatetime(sysdate)
   AND lg2.end_effective_dt_tm >= cnvtdatetime(sysdate)
  DETAIL
   lvindex = locateval(idx,1,lgcount,lg2.child_loc_cd,lg->lg[idx].parent_loc_cd)
   WHILE (lvindex != 0)
    lg->lg[lvindex].sequence_lg2 = lg2.sequence,lvindex = locateval(idx,(lvindex+ 1),lgcount,lg2
     .child_loc_cd,lg->lg[idx].parent_loc_cd)
   ENDWHILE
  WITH nocounter, expand = value(getexpandind(lgcount))
 ;end select
 CALL echo(build("FNRetrieveNurseUnit -> ",build2(cnvtint((curtime3 - fnretrievenurseunit))),"0 ms"))
 DECLARE fnretrievebeds = f8 WITH private, noconstant(curtime3)
 SELECT INTO "nl:"
  FROM location_group lg1
  WHERE expand(idx,1,lgcount,lg1.parent_loc_cd,lg->lg[idx].child_loc_cd)
   AND (lg1.root_loc_cd=request->view_id)
   AND lg1.active_ind=1
   AND lg1.beg_effective_dt_tm <= cnvtdatetime(sysdate)
   AND lg1.end_effective_dt_tm >= cnvtdatetime(sysdate)
  ORDER BY lg1.parent_loc_cd
  HEAD lg1.parent_loc_cd
   lg1count = 0, lvindex = locateval(idx,1,lgcount,lg1.parent_loc_cd,lg->lg[idx].child_loc_cd)
  DETAIL
   IF (lvindex > 0)
    lg1count += 1, stat = alterlist(lg->lg[lvindex].lg1,lg1count), lg->lg[lvindex].lg1[lg1count].
    child_loc_cd = lg1.child_loc_cd,
    lg->lg[lvindex].lg1[lg1count].sequence = lg1.sequence
   ENDIF
  WITH nocounter, expand = value(getexpandind(lgcount))
 ;end select
 CALL echo(build("FNRetrieveBeds -> ",build2(cnvtint((curtime3 - fnretrievebeds))),"0 ms"))
 DECLARE fnparsecollatelocations = f8 WITH private, noconstant(curtime3)
 FOR (roomcount = 1 TO lgcount)
  SET parentdisplay = trim(uar_get_code_display(lg->lg[roomcount].child_loc_cd))
  IF (size(lg->lg[roomcount].lg1,5) > 0)
   FOR (bedcount = 1 TO size(lg->lg[roomcount].lg1,5))
     SET childdisplay = trim(uar_get_code_display(lg->lg[roomcount].lg1[bedcount].child_loc_cd))
     SET totalcount += 1
     SET stat = alterlist(temp->qual,totalcount)
     SET temp->qual[totalcount].code = lg->lg[roomcount].lg1[bedcount].child_loc_cd
     SET temp->qual[totalcount].cdf = uar_get_code_meaning(lg->lg[roomcount].lg1[bedcount].
      child_loc_cd)
     SET temp->qual[totalcount].desc = concat(trim(parentdisplay),", ",trim(childdisplay))
     SET temp->qual[totalcount].sequence_lg1 = lg->lg[roomcount].lg1[bedcount].sequence
     SET temp->qual[totalcount].sequence = lg->lg[roomcount].sequence
     SET temp->qual[totalcount].sequence_lg2 = lg->lg[roomcount].sequence_lg2
   ENDFOR
  ELSE
   SET totalcount += 1
   SET stat = alterlist(temp->qual,totalcount)
   SET temp->qual[totalcount].code = lg->lg[roomcount].child_loc_cd
   SET temp->qual[totalcount].cdf = uar_get_code_meaning(lg->lg[roomcount].child_loc_cd)
   SET temp->qual[totalcount].desc = trim(parentdisplay)
   SET temp->qual[totalcount].sequence = lg->lg[roomcount].sequence
   SET temp->qual[totalcount].sequence_lg2 = lg->lg[roomcount].sequence_lg2
  ENDIF
 ENDFOR
 CALL echo(build("FNParseCollateLocations -> ",build2(cnvtint((curtime3 - fnparsecollatelocations))),
   "0 ms"))
 DECLARE fnretrievebedstatus = f8 WITH private, noconstant(curtime3)
 SELECT INTO "nl:"
  FROM bed b
  WHERE expand(idx,1,totalcount,b.location_cd,temp->qual[idx].code)
  DETAIL
   lvindex = locateval(idx,1,totalcount,b.location_cd,temp->qual[idx].code)
   IF (lvindex > 0)
    IF (b.location_cd=0.0)
     temp->qual[lvindex].status_cd = 0.0
    ELSE
     temp->qual[lvindex].status_cd = b.bed_status_cd
    ENDIF
   ENDIF
  WITH nocounter, expand = value(getexpandind(totalcount)), orahintcbo("index(b XPKBED)")
 ;end select
 CALL echo(build("FNRetrieveBedStatus -> ",build2(cnvtint((curtime3 - fnretrievebedstatus))),"0 ms"))
 SET stat = alterlist(reply->qual,totalcount)
 IF (totalcount > 0)
  SELECT INTO "nl:"
   FROM (dummyt d  WITH seq = value(totalcount))
   ORDER BY temp->qual[d.seq].sequence_lg2, temp->qual[d.seq].sequence, temp->qual[d.seq].
    sequence_lg1
   DETAIL
    replycount += 1, reply->qual[replycount].code = temp->qual[d.seq].code, reply->qual[replycount].
    cdf = temp->qual[d.seq].cdf,
    reply->qual[replycount].desc = temp->qual[d.seq].desc, reply->qual[replycount].status_cd = temp->
    qual[d.seq].status_cd
   WITH nocounter
  ;end select
 ENDIF
 IF (replycount=0)
  SET reply->status_data.status = "Z"
  GO TO endscript
 ENDIF
 DECLARE ncheckoutcount = i4 WITH noconstant(0)
 SET lvindex = locateval(idx,1,replycount,"CHECKOUT",reply->qual[idx].cdf)
 WHILE (lvindex > 0)
   SET ncheckoutcount += 1
   SET stat = alterlist(rcheckout->list,ncheckoutcount)
   SET rcheckout->list[ncheckoutcount].cd = reply->qual[lvindex].code
   SET lvindex = locateval(idx,(lvindex+ 1),replycount,"CHECKOUT",reply->qual[idx].cdf)
 ENDWHILE
 DECLARE fnretrievepatientcount = f8 WITH private, noconstant(curtime3)
 SELECT INTO "nl:"
  tl.location_cd
  FROM tracking_locator tl,
   tracking_item ti,
   person p,
   encounter e
  PLAN (tl
   WHERE expand(idx,1,replycount,tl.location_cd,reply->qual[idx].code)
    AND tl.depart_dt_tm=cnvtdatetime("31 DEC 2100"))
   JOIN (ti
   WHERE ti.tracking_id=tl.tracking_id
    AND ti.cur_tracking_locator_id=tl.tracking_locator_id
    AND ti.tracking_type_flag=0
    AND ti.encntr_id != 0.0
    AND ti.person_id != 0.0
    AND ti.active_ind=1)
   JOIN (p
   WHERE p.person_id=ti.person_id
    AND p.active_ind=1
    AND p.beg_effective_dt_tm <= cnvtdatetime(sysdate)
    AND p.end_effective_dt_tm >= cnvtdatetime(sysdate))
   JOIN (e
   WHERE e.encntr_id=ti.encntr_id
    AND e.active_ind=1
    AND e.beg_effective_dt_tm <= cnvtdatetime(sysdate)
    AND e.end_effective_dt_tm >= cnvtdatetime(sysdate))
  ORDER BY tl.location_cd
  HEAD tl.location_cd
   lvindex = locateval(idx,1,replycount,tl.location_cd,reply->qual[idx].code)
   IF (lvindex > 0)
    reply->qual[lvindex].pt_count = 0
   ENDIF
   IF ((reply->qual[lvindex].cdf="CHECKOUT"))
    lvindex = 0
   ENDIF
  DETAIL
   IF (lvindex > 0)
    reply->qual[lvindex].pt_count += 1
   ENDIF
  WITH nocounter, expand = value(getexpandind(replycount)), orahintcbo(
    "leading(g1_1 tl ti p e) use_nl(ti p e)","index(tl xie1tracking_locator)",
    "index(ti xpktracking_item)","index(p xpkperson)","index(e xpkencounter)")
 ;end select
 CALL echo(build("FNRetrievePatientCount -> ",build2(cnvtint((curtime3 - fnretrievepatientcount))),
   "0 ms"))
 DECLARE scheckoutlookback = vc WITH noconstant("7,D")
 CALL loadpreferences(0)
 CALL echo(build("Final Preference = ",scheckoutlookback))
 IF (ncheckoutcount > 0)
  DECLARE fnretrievecheckoutcount = f8 WITH private, noconstant(curtime3)
  SELECT INTO "nl:"
   tl.location_cd, tl.tracking_id
   FROM tracking_locator tl,
    tracking_item ti,
    tracking_checkin tc,
    person p,
    encounter e
   PLAN (tl
    WHERE tl.depart_dt_tm BETWEEN cnvtdatetime(cnvtlookbehind(scheckoutlookback)) AND cnvtdatetime(
     sysdate)
     AND expand(idx,1,ncheckoutcount,tl.location_cd,rcheckout->list[idx].cd))
    JOIN (ti
    WHERE ti.tracking_id=tl.tracking_id
     AND ti.tracking_id != 0.0
     AND ti.tracking_type_flag=0
     AND ti.cur_tracking_locator_id=0.0
     AND ti.active_ind=1)
    JOIN (tc
    WHERE tc.tracking_id=ti.tracking_id
     AND tc.checkout_dt_tm != cnvtdatetime("31 DEC 2100"))
    JOIN (p
    WHERE p.person_id=ti.person_id
     AND p.person_id != 0.0
     AND p.active_ind=1
     AND p.beg_effective_dt_tm <= cnvtdatetime(sysdate)
     AND p.end_effective_dt_tm >= cnvtdatetime(sysdate))
    JOIN (e
    WHERE e.encntr_id=ti.encntr_id
     AND e.encntr_id != 0.0
     AND e.active_ind=1
     AND e.disch_dt_tm=null
     AND e.beg_effective_dt_tm <= cnvtdatetime(sysdate)
     AND e.end_effective_dt_tm >= cnvtdatetime(sysdate))
   ORDER BY tl.location_cd, tl.tracking_id
   HEAD tl.location_cd
    lvindex = locateval(idx,1,replycount,"CHECKOUT",reply->qual[idx].cdf,
     tl.location_cd,reply->qual[idx].code)
    IF (lvindex > 0)
     reply->qual[lvindex].pt_count = 0
    ENDIF
   HEAD tl.tracking_id
    IF (lvindex > 0)
     reply->qual[lvindex].pt_count += 1
    ENDIF
   WITH nocounter
  ;end select
  CALL echo(build("FNRetrieveCheckoutCount -> ",build2(cnvtint((curtime3 - fnretrievecheckoutcount))),
    "0 ms"))
 ENDIF
 DECLARE fnretrieveprearrival = f8 WITH private, noconstant(curtime3)
 SELECT INTO "nl:"
  tl.location_cd
  FROM tracking_locator tl,
   tracking_item ti,
   tracking_prearrival tp
  PLAN (tl
   WHERE expand(idx,1,replycount,tl.location_cd,reply->qual[idx].code)
    AND tl.depart_dt_tm=cnvtdatetime("31 DEC 2100"))
   JOIN (ti
   WHERE ti.tracking_id=tl.tracking_id
    AND ti.cur_tracking_locator_id=tl.tracking_locator_id
    AND ti.parent_entity_name="TRACKING_PREARRIVAL"
    AND ti.encntr_id=0.0
    AND ti.person_id=0.0
    AND ti.parent_entity_id != 0.0
    AND ti.tracking_type_flag=0
    AND ti.active_ind=1)
   JOIN (tp
   WHERE tp.tracking_prearrival_id=ti.parent_entity_id)
  ORDER BY tl.location_cd
  HEAD tl.location_cd
   lvindex = locateval(idx,1,replycount,tl.location_cd,reply->qual[idx].code)
  DETAIL
   IF (lvindex > 0)
    reply->qual[lvindex].pt_count += 1
   ENDIF
  WITH nocounter, expand = value(getexpandind(replycount)), orahintcbo(
    "leading(g1_1 tl ti tp) use_nl(ti tp)","index(tl xie1tracking_locator)",
    "index(ti xpktracking_item)","index(tp xpktracking_prearrival)")
 ;end select
 CALL echo(build("FNRetrievePrearrival -> ",build2(cnvtint((curtime3 - fnretrieveprearrival))),"0 ms"
   ))
 DECLARE fnretrieveheldcount = f8 WITH private, noconstant(curtime3)
 SELECT INTO "nl:"
  p.name_full_formatted, ti.base_loc_cd
  FROM tracking_locator tl,
   tracking_item ti,
   person p,
   encounter e
  PLAN (ti
   WHERE expand(idx,1,replycount,ti.base_loc_cd,reply->qual[idx].code)
    AND ti.end_tracking_dt_tm=null
    AND ti.active_ind=1
    AND ti.base_loc_cd != 0.0
    AND ti.tracking_type_flag=0)
   JOIN (tl
   WHERE tl.tracking_locator_id=ti.cur_tracking_locator_id
    AND tl.location_cd != ti.base_loc_cd)
   JOIN (p
   WHERE p.person_id=ti.person_id
    AND p.active_ind=1
    AND p.beg_effective_dt_tm <= cnvtdatetime(sysdate)
    AND p.end_effective_dt_tm >= cnvtdatetime(sysdate))
   JOIN (e
   WHERE e.encntr_id=ti.encntr_id
    AND e.active_ind=1
    AND e.beg_effective_dt_tm <= cnvtdatetime(sysdate)
    AND e.end_effective_dt_tm >= cnvtdatetime(sysdate))
  ORDER BY ti.base_loc_cd
  HEAD ti.base_loc_cd
   lvindex = locateval(idx,1,replycount,ti.base_loc_cd,reply->qual[idx].code)
   IF (lvindex > 0)
    reply->qual[lvindex].held_count = 0
   ENDIF
  DETAIL
   IF (lvindex > 0)
    IF ((reply->qual[lvindex].held_count > 0))
     reply->qual[lvindex].held_for = concat(trim(reply->qual[lvindex].held_for),"; ",trim(p
       .name_full_formatted))
    ELSE
     reply->qual[lvindex].held_for = trim(p.name_full_formatted)
    ENDIF
    reply->qual[lvindex].held_count += 1
   ENDIF
  WITH nocounter, expand = value(getexpandind(replycount)), orahintcbo("index(ti XIE6TRACKING_ITEM)",
    "index(tl XPKTRACKING_LOCATOR)","index(p XPKPERSON)","index(e XPKENCOUNTER)")
 ;end select
 CALL echo(build("FNRetrieveHeldCount -> ",build2(cnvtint((curtime3 - fnretrieveheldcount))),"0 ms"))
 SET reply->status_data.status = "S"
 SUBROUTINE (loadpreferences(param=i4) =null)
   DECLARE fnloadpreferences = f8 WITH private, noconstant(curtime3)
   DECLARE scheckoutlocpatientcountdefpref = vc
   SET pref_request->context = "default"
   SET pref_request->context_id = "system"
   SET pref_request->section = "module"
   SET pref_request->section_id = "tracking"
   SET stat = alterlist(pref_request->groups,1)
   SET pref_request->groups[1].name = "common"
   SET pref_request->debug = "0"
   CALL echo("Executing fn_get_prefs...")
   EXECUTE fn_get_prefs  WITH replace("REQUEST",pref_request), replace("REPLY",pref_reply)
   DECLARE curvalue = i4 WITH noconstant(0)
   DECLARE curpref = i4 WITH noconstant(1)
   DECLARE prefcnt = i4 WITH noconstant(size(pref_reply->entries,5))
   CALL echo(build("curPref = ",curpref,"prefCnt = ",prefcnt))
   FOR (curpref = 1 TO prefcnt)
     IF ((pref_reply->entries[curpref].name="checkout location patient count"))
      FOR (curvalue = 1 TO size(pref_reply->entries[curpref].values,5))
        SET scheckoutlocpatientcountdefpref = pref_reply->entries[curpref].values[curvalue].value
      ENDFOR
     ENDIF
   ENDFOR
   CALL echo(build("The default preference for checkout location patient count is:",
     scheckoutlocpatientcountdefpref))
   IF (size(trim(scheckoutlocpatientcountdefpref),1) > 0
    AND cnvtint(trim(scheckoutlocpatientcountdefpref)) > 0)
    SET scheckoutlookback = build(scheckoutlocpatientcountdefpref,",D")
    CALL echo(build("Updated Preference = ",scheckoutlookback))
   ENDIF
   CALL echo(build("FNLoadPreferences -> ",build2(cnvtint((curtime3 - fnloadpreferences))),"0 ms"))
 END ;Subroutine
#endscript
 CALL echo(build("FNComplete -> ",build2(cnvtint((curtime3 - fncomplete))),"0 ms"))
END GO
1)

250917:091720 WHITTLJ2_DVD1              Cost 0.00 Cpu 0.00 Ela 0.00 Dio   0 O0M0R0 P1R0